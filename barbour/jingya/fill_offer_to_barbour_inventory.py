# -*- coding: utf-8 -*-
"""
Barbour 回填（映射版，含价格计算，修复版 2025-09-14）
- 入口函数：backfill_barbour_inventory_mapped_only()（未改名、未改参）。
- 修复 original_price_gbp 串联、URL/Title 回填、价格计算（参考 generate_barbour_prices_from_avg 的 price_utils 用法）。
"""

from __future__ import annotations
from typing import List, Tuple, Iterable
import csv
from pathlib import Path

from sqlalchemy import create_engine, text
from sqlalchemy.engine import Connection

# 项目配置
from config import BRAND_CONFIG, BARBOUR  # BARBOUR 仅用于 DEBUG 导出目录

# 价格工具（与 generate_barbour_prices_from_avg 一致）
from common_taobao.core.price_utils import calculate_jingya_prices

# 尺码归一化：优先用你项目里的函数，找不到就降级为轻量实现
try:
    from common_taobao.size_utils import clean_size_for_barbour as _clean_size
except Exception:
    import re
    def _clean_size(s: str) -> str:
        """轻量降级：去 'UK '、去空格/点/斜杠、小写；兼容 2xl/xxl 等写法"""
        x = (s or "").strip()
        x = re.sub(r"(?i)^uk\s*", "", x)
        x = re.sub(r"[\s./-]+", "", x)
        x = x.lower()
        x = x.replace("2xl", "xxl").replace("3xl", "xxxl")
        return x or "unknown"

# 有货时写入的“占位库存”
STOCK_WHEN_AVAILABLE = 5

DEBUG_EXPORT = Path(BARBOUR["PUBLICATION_DIR"]) / "supplier_map_unmatched_debug.csv"


# ============ 价格计算相关 ============

def compute_rmb_price(base_gbp: float):
    """参考 generate_barbour_prices_from_avg：传入 GBP 基价，返回 (鲸芽未税, 淘宝零售) RMB。"""
    try:
        if base_gbp is None:
            return None, None
        untaxed, retail = calculate_jingya_prices(float(base_gbp))
        return (float(untaxed) if untaxed is not None else None,
                float(retail) if retail is not None else None)
    except Exception:
        return None, None


def _ensure_price_columns(conn: Connection):
    """自动建列（幂等）。"""
    conn.execute(text("""
        ALTER TABLE barbour_inventory
          ADD COLUMN IF NOT EXISTS jingya_price_rmb   NUMERIC(12,2),
          ADD COLUMN IF NOT EXISTS taobao_price_rmb   NUMERIC(12,2),
          ADD COLUMN IF NOT EXISTS base_price_gbp     NUMERIC(10,2),
          ADD COLUMN IF NOT EXISTS exchange_rate_used NUMERIC(8,4);
    """))


def _num_or_null(v):
    try:
        return float(v) if v is not None else None
    except Exception:
        return None


def _update_prices_for_bi_ids(conn: Connection, bi_ids: Iterable[int]):
    """对本轮命中的 bi.id 计算并写入 RMB 价格。"""
    ids = list(bi_ids)
    if not ids:
        return

    rows = list(conn.execute(text("""
        SELECT id,
               COALESCE(discount_price_gbp, source_price_gbp) AS base_gbp
        FROM barbour_inventory
        WHERE id = ANY(:ids)
    """), {"ids": ids}).mappings())

    payload = []
    for r in rows:
        bi_id = r["id"]
        base_gbp = r["base_gbp"]
        jy, tb = compute_rmb_price(base_gbp)
        payload.append({
            "base_price_gbp":    _num_or_null(base_gbp),
            "exchange_rate_used": None,  # 交给 price_utils 内部策略
            "jingya_price_rmb":  _num_or_null(jy),
            "taobao_price_rmb":  _num_or_null(tb),
            "bi_id":             bi_id
        })

    if payload:
        conn.execute(text("""
            UPDATE barbour_inventory
            SET base_price_gbp     = :base_price_gbp,
                exchange_rate_used = :exchange_rate_used,
                jingya_price_rmb   = :jingya_price_rmb,
                taobao_price_rmb   = :taobao_price_rmb
            WHERE id = :bi_id
        """), payload)


# ============ SQL 片段 ============

SQL_CREATE_TMP = [
    text("""
        DROP TABLE IF EXISTS tmp_bi;
        CREATE TEMP TABLE tmp_bi(
            bi_id        INT,
            product_code VARCHAR(50),
            size_norm    VARCHAR(50)
        );
    """),
    text("""
        DROP TABLE IF EXISTS tmp_o;
        CREATE TEMP TABLE tmp_o(
            o_id         INT GENERATED BY DEFAULT AS IDENTITY,
            color_code   VARCHAR(50),
            size_norm    VARCHAR(50),
            site_name    VARCHAR(100),
            offer_url    TEXT,
            price_gbp    NUMERIC(10,2),
            original_price_gbp NUMERIC(10,2),
            discount_price_gbp NUMERIC(10,2),
            eff_price    NUMERIC(10,2),
            stock_count  INT,
            last_checked TIMESTAMP
        );
    """),
]

SQL_STEP1_FILL_PRODUCT_INFO = text("""
    WITH bp AS (
      SELECT DISTINCT ON (product_code)
             product_code, title, product_description, gender, category, updated_at
      FROM barbour_products
      ORDER BY product_code, updated_at DESC NULLS LAST
    )
    UPDATE barbour_inventory AS bi
    SET
      product_title       = COALESCE(bi.product_title, bp.title),
      product_description = COALESCE(bp.product_description, bi.product_description),
      gender              = COALESCE(bi.gender, bp.gender),
      style_category      = COALESCE(bi.style_category, bp.category)
    FROM bp
    WHERE LOWER(bp.product_code) = LOWER(bi.product_code);
""")

SQL_BUILD_INV_ROWS = text("""
    SELECT bi.id, bi.product_code, bi.size
    FROM barbour_inventory bi
    JOIN barbour_supplier_map sm
      ON LOWER(sm.product_code) = LOWER(bi.product_code)
""")

SQL_BUILD_OFFER_ROWS = text("""
    SELECT
      bo.product_code,
      bo.site_name,
      bo.size,
      bo.offer_url,
      bo.price_gbp,
      bo.original_price_gbp,
      bo.sale_price_gbp,
      bo.stock_count,
      bo.last_checked
    FROM barbour_offers bo
    JOIN barbour_supplier_map sm
      ON LOWER(sm.product_code) = LOWER(bo.product_code)
     AND LOWER(sm.site_name)    = LOWER(bo.site_name)
    WHERE bo.is_active = TRUE
      AND bo.product_code IS NOT NULL
""")

SQL_INDEX_TMP = [
    text("CREATE INDEX ON tmp_bi(product_code, size_norm)"),
    text("CREATE INDEX ON tmp_o(color_code, size_norm)"),
]

SQL_BACKFILL_MATCHED = text(f"""
    WITH avail AS (
      SELECT
        tpo.color_code, tpo.size_norm, tpo.site_name, tpo.offer_url,
        tpo.price_gbp, tpo.original_price_gbp, tpo.discount_price_gbp,
        COALESCE(tpo.discount_price_gbp, tpo.price_gbp) AS eff_price,
        tpo.stock_count, tpo.last_checked
      FROM tmp_o tpo
    ),
    best AS (
      SELECT DISTINCT ON (color_code, size_norm)
             color_code, size_norm, site_name, offer_url,
             price_gbp, original_price_gbp, discount_price_gbp, eff_price, stock_count, last_checked
      FROM avail
      ORDER BY color_code, size_norm,
               CASE WHEN COALESCE(stock_count,0) > 0 THEN 0 ELSE 1 END,
               eff_price ASC NULLS LAST,
               last_checked DESC
    )
    UPDATE barbour_inventory AS bi
    SET
      source_site          = b.site_name,
      source_offer_url     = b.offer_url,
      source_price_gbp     = b.price_gbp,
      original_price_gbp   = b.original_price_gbp,
      discount_price_gbp   = b.discount_price_gbp,
      stock_count          = CASE WHEN COALESCE(b.stock_count,0) > 0
                                  THEN {STOCK_WHEN_AVAILABLE}
                                  ELSE 0
                             END,
      product_url          = COALESCE(bi.product_url, b.offer_url),
      last_checked         = NOW()
    FROM tmp_bi tbi
    JOIN best b
      ON b.color_code = tbi.product_code
     AND b.size_norm  = tbi.size_norm
    WHERE bi.id = tbi.bi_id
    RETURNING bi.id;
""")

SQL_BACKFILL_UNMATCHED_ZERO = text("""
    WITH miss AS (
      SELECT tbi.bi_id
      FROM tmp_bi tbi
      LEFT JOIN tmp_o tpo
        ON tpo.color_code = tbi.product_code
       AND tpo.size_norm  = tbi.size_norm
      WHERE tpo.o_id IS NULL
    )
    UPDATE barbour_inventory AS bi
    SET
      source_site        = NULL,
      source_offer_url   = NULL,
      source_price_gbp   = NULL,
      discount_price_gbp = NULL,
      original_price_gbp = NULL,
      stock_count        = 0,
      jingya_price_rmb   = NULL,
      taobao_price_rmb   = NULL,
      base_price_gbp     = NULL,
      exchange_rate_used = NULL,
      last_checked       = NOW()
    FROM miss
    WHERE bi.id = miss.bi_id;
""")


def backfill_barbour_inventory_mapped_only():
    cfg = BRAND_CONFIG["barbour"]["PGSQL_CONFIG"]
    engine = create_engine(
        f"postgresql+psycopg2://{cfg['user']}:{cfg['password']}@{cfg['host']}:{cfg['port']}/{cfg['dbname']}"
    )

    with engine.begin() as conn:  # type: Connection
        _ensure_price_columns(conn)

        for sql in SQL_CREATE_TMP:
            conn.execute(sql)

        conn.execute(SQL_STEP1_FILL_PRODUCT_INFO)

        conn.execute(text("""
            UPDATE barbour_inventory AS bi
            SET product_url = bp.source_url
            FROM (
              SELECT DISTINCT ON (product_code)
                     product_code, source_url, updated_at
              FROM barbour_products
              ORDER BY product_code, updated_at DESC NULLS LAST
            ) AS bp
            WHERE LOWER(bp.product_code) = LOWER(bi.product_code)
              AND (bi.product_url IS NULL OR bi.product_url = '');
        """))

        inv_rows = conn.execute(SQL_BUILD_INV_ROWS).fetchall()
        inv_values: List[Tuple] = []
        for bi_id, code, size in inv_rows:
            size_n = _clean_size(size)
            if size_n and size_n != "unknown":
                inv_values.append((bi_id, (code or "").strip(), size_n))
        if inv_values:
            conn.exec_driver_sql(
                "INSERT INTO tmp_bi(bi_id, product_code, size_norm) VALUES (%s,%s,%s)",
                inv_values
            )
        conn.execute(SQL_INDEX_TMP[0])

        off_rows = conn.execute(SQL_BUILD_OFFER_ROWS).fetchall()
        off_values: List[Tuple] = []
        for code, site, size, url, price, orig_price, sale_price, stock, ts in off_rows:
            size_n = _clean_size(size)
            if size_n and size_n != "unknown":
                eff_price = sale_price if sale_price is not None else price
                off_values.append((
                    code.strip(),
                    size_n.strip(),
                    site.strip(),
                    url,
                    price,
                    orig_price,
                    sale_price,
                    eff_price,
                    stock, ts
                ))
        if off_values:
            conn.exec_driver_sql(
                """INSERT INTO tmp_o(color_code, size_norm, site_name, offer_url,
                                      price_gbp, original_price_gbp, discount_price_gbp, eff_price, stock_count, last_checked)
                   VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)""",
                off_values
            )
        conn.execute(SQL_INDEX_TMP[1])

        matched_rs = conn.execute(SQL_BACKFILL_MATCHED)
        try:
            matched_ids = [r[0] for r in matched_rs.fetchall()]
        except Exception:
            matched_ids = []

        conn.execute(SQL_BACKFILL_UNMATCHED_ZERO)

        _update_prices_for_bi_ids(conn, matched_ids)

    print(f"✅ 映射回填完成：命中 {len(matched_ids)} 行；未命中已置零并清空售价。")


if __name__ == "__main__":
    backfill_barbour_inventory_mapped_only()
