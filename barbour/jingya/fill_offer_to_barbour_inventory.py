# -*- coding: utf-8 -*-
"""
Barbour 回填（映射版）：
- 仅按 barbour_supplier_map 指定的 supplier 进行价格/库存回填；
- 尺码统一用 clean_size_for_barbour 归一化；
- 命中 (code+size+supplier) → 回填；未命中 → 库存置 0（价格不改）；
- Step1 保持：从 barbour_products 回填基础信息（title/desc/gender/category）。
"""

from __future__ import annotations
from typing import List, Tuple
from datetime import datetime

from sqlalchemy import create_engine, text
from sqlalchemy.engine import Connection

# 项目配置
from config import BRAND_CONFIG

# 尺码归一化：优先用你项目里的函数，找不到就降级为轻量实现
try:
    from barbour.core.sizes import clean_size_for_barbour as _clean_size
except Exception:
    import re
    def _clean_size(s: str) -> str:
        """轻量降级：去‘UK ’、去空格/点/斜杠，小写；兼容 2xl/xxl 等常见写法"""
        x = (s or "").strip()
        x = re.sub(r"(?i)^uk\s*", "", x)
        x = re.sub(r"[\s./-]+", "", x)
        x = x.lower()
        x = x.replace("2xl", "xxl").replace("3xl", "xxxl")
        return x or "unknown"

# 可下单时给的“库存数字占位”（如果你更想用 offers 的 stock_count，把它改成 COALESCE(b.stock_count,0) 即可）
STOCK_WHEN_AVAILABLE = 5

# ---------- SQL 片段 ----------
SQL_CREATE_TMP = [
    # inventory 临时表：只挑“有映射的商品编码”的行，并做 size_norm
    text("""
    DROP TABLE IF EXISTS tmp_bi;
    CREATE TEMP TABLE tmp_bi(
        bi_id        INT,
        product_code VARCHAR(50),
        size_norm    VARCHAR(50)
    );
    """),

    # offers 临时表：只挑“(code, 映射站点)”的报价，做 size_norm，取有效价
    text("""
    DROP TABLE IF EXISTS tmp_o;
    CREATE TEMP TABLE tmp_o(
        o_id         INT GENERATED BY DEFAULT AS IDENTITY,
        color_code   VARCHAR(50),
        size_norm    VARCHAR(50),
        site_name    VARCHAR(100),
        offer_url    TEXT,
        price_gbp    NUMERIC(10,2),
        discount_price_gbp NUMERIC(10,2),
        eff_price    NUMERIC(10,2),
        stock_count  INT,
        last_checked TIMESTAMP
    );
    """),
]

SQL_STEP1_FILL_PRODUCT_INFO = text("""
/* 用 products 的“最近一条”基础信息回填到 inventory */
WITH bp AS (
  SELECT DISTINCT ON (product_code)
         product_code, title, product_description, gender, category, updated_at
  FROM barbour_products
  ORDER BY product_code, updated_at DESC NULLS LAST
)
UPDATE barbour_inventory AS bi
SET
  product_title       = COALESCE(bp.title, bi.product_title),
  product_description = COALESCE(bp.product_description, bi.product_description),
  gender              = COALESCE(bi.gender, bp.gender),
  style_category      = COALESCE(bi.style_category, bp.category)
FROM bp
WHERE LOWER(bp.product_code) = LOWER(bi.product_code);
""")

SQL_BUILD_INV_ROWS = text("""
SELECT bi.id, bi.product_code, bi.size
FROM barbour_inventory bi
JOIN barbour_supplier_map sm
  ON LOWER(sm.product_code) = LOWER(bi.product_code)
""")

SQL_BUILD_OFFER_ROWS = text("""
SELECT
  bo.product_code,
  bo.site_name,
  bo.size,
  bo.offer_url,
  bo.price_gbp,
  bo.sale_price_gbp,
  bo.stock_count,
  bo.last_checked
FROM barbour_offers bo
JOIN barbour_supplier_map sm
  ON LOWER(sm.product_code) = LOWER(bo.product_code)
 AND LOWER(sm.site_name)    = LOWER(bo.site_name)
WHERE bo.is_active = TRUE
  AND bo.product_code IS NOT NULL
""")

SQL_INDEX_TMP = [
    text("CREATE INDEX ON tmp_bi(product_code, size_norm)"),
    text("CREATE INDEX ON tmp_o(color_code, size_norm)"),
]

# 2A) 命中（映射站点 & 同尺码）：有货优先 → 低价 → 最新
SQL_BACKFILL_MATCHED = text(f"""
WITH avail AS (
  SELECT
    tpo.color_code, tpo.size_norm, tpo.site_name, tpo.offer_url,
    tpo.price_gbp, tpo.discount_price_gbp,
    COALESCE(tpo.discount_price_gbp, tpo.price_gbp) AS eff_price,
    tpo.stock_count, tpo.last_checked
  FROM tmp_o tpo
),
best AS (
  SELECT DISTINCT ON (color_code, size_norm)
         color_code, size_norm, site_name, offer_url,
         price_gbp, discount_price_gbp, eff_price, stock_count, last_checked
  FROM avail
  ORDER BY color_code, size_norm,
           CASE WHEN COALESCE(stock_count,0) > 0 THEN 0 ELSE 1 END,  -- 先有货
           eff_price ASC NULLS LAST,                                  -- 再低价
           last_checked DESC                                          -- 再新
)
UPDATE barbour_inventory AS bi
SET
  source_site        = b.site_name,
  source_offer_url   = b.offer_url,
  source_price_gbp   = b.price_gbp,
  discount_price_gbp = b.discount_price_gbp,
  stock_count        = COALESCE(b.stock_count, 0),                       -- 可下单用占位库存
  last_checked       = NOW()
FROM tmp_bi tbi
JOIN best b
  ON b.color_code = tbi.product_code
 AND b.size_norm  = tbi.size_norm
WHERE bi.id = tbi.bi_id
""")

# 2B) 未命中（映射站点下没有同尺码报价）：只把库存置 0，价格不变
SQL_BACKFILL_UNMATCHED_ZERO = text("""
WITH miss AS (
  SELECT tbi.bi_id
  FROM tmp_bi tbi
  LEFT JOIN tmp_o tpo
    ON tpo.color_code = tbi.product_code
   AND tpo.size_norm  = tbi.size_norm
  WHERE tpo.o_id IS NULL
)
UPDATE barbour_inventory AS bi
SET
  stock_count  = 0,
  last_checked = NOW()
FROM miss
WHERE bi.id = miss.bi_id
""")


import csv
from pathlib import Path
from config import BARBOUR  # 只为拿 PUBLICATION_DIR

DEBUG_EXPORT = Path(BARBOUR["PUBLICATION_DIR"]) / "supplier_map_unmatched_debug.csv"

def _dbg(conn):
    # 1) 统计 tmp 表规模 & unknown 比例
    bi_counts = conn.execute(text("""
        SELECT COUNT(*) AS n, SUM(CASE WHEN size_norm='unknown' THEN 1 ELSE 0 END) AS n_unk
        FROM tmp_bi
    """)).fetchone()
    o_counts = conn.execute(text("""
        SELECT COUNT(*) AS n, SUM(CASE WHEN size_norm='unknown' THEN 1 ELSE 0 END) AS n_unk
        FROM tmp_o
    """)).fetchone()
    print(f"[DBG] tmp_bi 行数={bi_counts[0]} | unknown={bi_counts[1]}")
    print(f"[DBG] tmp_o  行数={o_counts[0]} | unknown={o_counts[1]}")

    # 2) 统计“尺码完全无交集”的编码（映射站点内）
    rows = conn.execute(text("""
        WITH inv AS (
          SELECT product_code, size_norm FROM tmp_bi
        ),
        off AS (
          SELECT color_code AS product_code, size_norm, site_name FROM tmp_o
        ),
        m AS (
          SELECT DISTINCT LOWER(sm.product_code) AS code, LOWER(sm.site_name) AS site
          FROM barbour_supplier_map sm
        ),
        inv_g AS (
          SELECT i.product_code, array_agg(DISTINCT i.size_norm) AS inv_sizes
          FROM inv i GROUP BY i.product_code
        ),
        off_g AS (
          SELECT o.product_code, o.site_name, array_agg(DISTINCT o.size_norm) AS off_sizes
          FROM off o GROUP BY o.product_code, o.site_name
        )
        SELECT ig.product_code, mg.site,
               ig.inv_sizes,
               COALESCE(og.off_sizes, ARRAY[]::varchar[]) AS off_sizes
        FROM m mg
        JOIN inv_g ig ON ig.product_code = mg.code
        LEFT JOIN off_g og ON og.product_code = mg.code AND og.site_name = mg.site
        WHERE (og.off_sizes IS NULL) 
           OR (NOT EXISTS (
                 SELECT 1 FROM unnest(ig.inv_sizes) s1
                 INTERSECT
                 SELECT 1 FROM unnest(COALESCE(og.off_sizes, ARRAY[]::varchar[])) s2
               ))
        LIMIT 100
    """)).fetchall()

    print(f"[DBG] 尺码完全无交集的编码数（样例最多100）：{len(rows)}")
    if rows[:1]:
        c0, s0, inv_set, off_set = rows[0]
        print(f"  示例 code={c0} site={s0}\n    inv_sizes={inv_set}\n    off_sizes={off_set}")

    # 3) 导出 CSV 便于排查
    if rows:
        with DEBUG_EXPORT.open("w", newline="", encoding="utf-8-sig") as f:
            w = csv.writer(f)
            w.writerow(["product_code", "site", "inv_sizes", "off_sizes"])
            for c, s, inv_set, off_set in rows:
                w.writerow([c, s, " ".join(sorted(set(inv_set or []))), " ".join(sorted(set(off_set or [])))])
        print(f"[DBG] 已导出未命中明细：{DEBUG_EXPORT}")


def backfill_barbour_inventory_mapped_only():
    cfg = BRAND_CONFIG["barbour"]["PGSQL_CONFIG"]
    engine = create_engine(
        f"postgresql+psycopg2://{cfg['user']}:{cfg['password']}@{cfg['host']}:{cfg['port']}/{cfg['dbname']}"
    )

    with engine.begin() as conn:  # type: Connection
        # Step 0: 创建临时表
        for sql in SQL_CREATE_TMP:
            conn.execute(sql)

        # Step 1: 基础信息回填（title/desc/gender/category）
        conn.execute(SQL_STEP1_FILL_PRODUCT_INFO)  # 基于 products 的最新记录回填。:contentReference[oaicite:2]{index=2}

        # Step 2: 组装 tmp_bi（用 clean_size_for_barbour 归一化）
        inv_rows = conn.execute(SQL_BUILD_INV_ROWS).fetchall()
        inv_values: List[Tuple] = []
        for bi_id, code, size in inv_rows:
            size_n = _clean_size(size)
            if size_n and size_n != "unknown":
                inv_values.append((bi_id, (code or "").strip(), size_n))

        if inv_values:
            conn.exec_driver_sql("INSERT INTO tmp_bi(bi_id, product_code, size_norm) VALUES (%s,%s,%s)", inv_values)
        # 索引
        conn.execute(SQL_INDEX_TMP[0])

        # Step 3: 组装 tmp_o（映射站点 + clean_size_for_barbour + 有效价）
        off_rows = conn.execute(SQL_BUILD_OFFER_ROWS).fetchall()
        off_values: List[Tuple] = []
        for code, site, size, url, price, sale_price, stock, ts in off_rows:
            size_n = _clean_size(size)
            if size_n and size_n != "unknown":
                off_values.append((
                    (code or "").strip(),
                    (size_n or "").strip(),
                    (site or "").strip(),
                    url, price,
                    sale_price,                 # 作为 discount_price_gbp 使用
                    sale_price,                 # eff_price = sale_price_gbp（已是 COALESCE 结果）
                    stock, ts
                ))
        if off_values:
            conn.exec_driver_sql("""
                INSERT INTO tmp_o(color_code, size_norm, site_name, offer_url,
                                   price_gbp, discount_price_gbp, eff_price, stock_count, last_checked)
                VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s)
            """, off_values)
        # 索引
        conn.execute(SQL_INDEX_TMP[1])

        if True:  # 临时打开
          _dbg(conn)

        # Step 4A: 命中 (code + size + supplier) → 完整回填
        r1 = conn.execute(SQL_BACKFILL_MATCHED)
        n1 = r1.rowcount if hasattr(r1, "rowcount") else None

        # Step 4B: 未命中 → 库存置 0（价格不变）
        r2 = conn.execute(SQL_BACKFILL_UNMATCHED_ZERO)
        n2 = r2.rowcount if hasattr(r2, "rowcount") else None

    print(f"✅ 映射回填完成：命中 {n1 if n1 is not None else '?'} 行；未命中置零 {n2 if n2 is not None else '?'} 行。")


if __name__ == "__main__":
    backfill_barbour_inventory_mapped_only()
