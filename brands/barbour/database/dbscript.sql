-- =========================================================
-- Barbour 数据库结构重建脚本
-- 运行效果：删除所有旧对象 → 重新建立所有表、函数、触发器、索引
-- =========================================================


-- =========================================================
-- SECTION 1：清除旧对象
-- 顺序：函数（CASCADE 自动连带删除依赖触发器）→ 表
-- =========================================================

-- 1-a. 删除触发器函数（CASCADE 会自动删除绑定在各表上的触发器）
DROP FUNCTION IF EXISTS set_updated_at()        CASCADE;
DROP FUNCTION IF EXISTS barbour_offers_touch()  CASCADE;
DROP FUNCTION IF EXISTS trg_bpc_touch()         CASCADE;

-- 1-b. 删除表（按外键依赖顺序，CASCADE 处理残余约束）
DROP TABLE IF EXISTS keyword_lexicon            CASCADE;
DROP TABLE IF EXISTS barbour_offers             CASCADE;
DROP TABLE IF EXISTS barbour_inventory          CASCADE;
DROP TABLE IF EXISTS barbour_supplier_map       CASCADE;
DROP TABLE IF EXISTS barbour_product_candidates CASCADE;
DROP TABLE IF EXISTS barbour_products           CASCADE;
DROP TABLE IF EXISTS barbour_color_map          CASCADE;


-- =========================================================
-- SECTION 2：公共函数
-- =========================================================

-- 通用 updated_at 自动更新函数
CREATE FUNCTION set_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at := NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- =========================================================
-- SECTION 3：表定义
-- =========================================================

-- ---------- 3-1. keyword_lexicon：关键词词库 ----------
CREATE TABLE keyword_lexicon (
    id         BIGSERIAL    PRIMARY KEY,
    brand      TEXT         NOT NULL,           -- 'barbour'
    level      SMALLINT     NOT NULL,           -- 1=L1, 2=L2
    keyword    TEXT         NOT NULL,           -- 规范化后的词（小写、只字母）
    category   TEXT,                            -- L2 可选：material/season/style/function/category...
    weight     NUMERIC      DEFAULT 1.0,        -- 预留：不同词权重
    is_active  BOOLEAN      DEFAULT TRUE,
    created_at TIMESTAMPTZ  DEFAULT NOW(),
    UNIQUE (brand, level, keyword)
);

CREATE INDEX idx_keyword_lexicon_brand_level ON keyword_lexicon (brand, level);
CREATE INDEX idx_keyword_lexicon_keyword     ON keyword_lexicon (keyword);


-- ---------- 3-2. barbour_color_map：颜色简码映射表 ----------
-- 用途：颜色英文名 ↔ 颜色简码（BK/NY/OL 等）标准映射
CREATE TABLE barbour_color_map (
    id           SERIAL       PRIMARY KEY,
    color_code   VARCHAR(4)   NOT NULL,         -- 如 'NY', 'OL', 'BK'
    raw_name     TEXT         NOT NULL,         -- 原始颜色名，如 'Navy/Classic'
    -- norm_key 规则（应用层构造）：
    --   全部小写 → 非字母当分隔符 → 拆词去重排序 → 空格拼接
    --   例：'Oatmeal / Ancient Tartan' -> 'ancient oatmeal tartan'
    norm_key     TEXT         NOT NULL,
    source       VARCHAR(50),                   -- products / config / manual / txt_problem ...
    is_confirmed BOOLEAN      DEFAULT FALSE,
    created_at   TIMESTAMP    DEFAULT NOW(),
    updated_at   TIMESTAMP    DEFAULT NOW(),
    UNIQUE (color_code, raw_name)
);

CREATE TRIGGER trg_barbour_color_map_updated
BEFORE UPDATE ON barbour_color_map
FOR EACH ROW EXECUTE FUNCTION set_updated_at();


-- ---------- 3-3. barbour_products：产品信息表 ----------
CREATE TABLE barbour_products (
    id           SERIAL       PRIMARY KEY,
    product_code VARCHAR(50)  NOT NULL,         -- 如 MWX0339NY91
    size         VARCHAR(20)  NOT NULL,         -- 如 M / UK 10 / XL
    style_name   VARCHAR(255) NOT NULL,
    color        VARCHAR(100) NOT NULL,
    gender       VARCHAR(20),                   -- Men / Women / Kids
    category     VARCHAR(100),                  -- Jacket / Coat / Shirt / Bag ...
    title        VARCHAR(255),
    product_description TEXT,
    match_keywords_l1   TEXT[],
    match_keywords_l2   TEXT[],
    source_site  VARCHAR(100),                  -- barbour / O&C / PMD / manual
    source_url   TEXT,
    source_rank  INT          DEFAULT 999,      -- 0=官网, 1=有编码, 2=人工, 999=未知
    created_at   TIMESTAMP    DEFAULT CURRENT_TIMESTAMP,
    updated_at   TIMESTAMP    DEFAULT CURRENT_TIMESTAMP,
    UNIQUE (product_code, size)
);

CREATE TRIGGER trg_barbour_products_updated
BEFORE UPDATE ON barbour_products
FOR EACH ROW EXECUTE FUNCTION set_updated_at();


-- ---------- 3-4. barbour_offers：供应商报价表 ----------
CREATE FUNCTION barbour_offers_touch()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN
    NEW.last_seen    := NOW();
    NEW.last_checked := NOW();
    RETURN NEW;
END;
$$;

CREATE TABLE barbour_offers (
    id                   INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    site_name            VARCHAR(100)  NOT NULL,
    offer_url            TEXT          NOT NULL,
    size                 VARCHAR(20)   NOT NULL,
    product_code         VARCHAR(50),            -- 可空，后续回填
    price_gbp            NUMERIC(10,2),          -- TXT 原价（Product Price）
    original_price_gbp   NUMERIC(10,2),          -- TXT 折扣价（Adjusted / Now Price）
    sale_price_gbp       NUMERIC(10,2),          -- 策略+运费计算后的供货基准价
    stock_count          INT           DEFAULT 0,
    is_active            BOOLEAN       DEFAULT TRUE,
    first_seen           TIMESTAMP     DEFAULT NOW(),
    last_seen            TIMESTAMP     DEFAULT NOW(),
    last_checked         TIMESTAMP     DEFAULT NOW(),
    -- 相对于原价的折扣百分比（计算列）
    discount_pct NUMERIC(5,1) GENERATED ALWAYS AS (
        CASE
            WHEN price_gbp IS NOT NULL
             AND sale_price_gbp IS NOT NULL
             AND sale_price_gbp < price_gbp
            THEN ROUND((1 - sale_price_gbp / NULLIF(price_gbp, 0)) * 100, 1)
            ELSE 0
        END
    ) STORED,
    CONSTRAINT uq_barbour_offer   UNIQUE (site_name, offer_url, size),
    CONSTRAINT chk_price_nonneg   CHECK  (
        (price_gbp          IS NULL OR price_gbp          >= 0) AND
        (original_price_gbp IS NULL OR original_price_gbp >= 0) AND
        (sale_price_gbp     IS NULL OR sale_price_gbp     >= 0)
    )
);

CREATE TRIGGER trg_barbour_offers_touch
BEFORE UPDATE ON barbour_offers
FOR EACH ROW EXECUTE FUNCTION barbour_offers_touch();


-- ---------- 3-5. barbour_inventory：发布/库存汇总表 ----------
CREATE TABLE barbour_inventory (
    id                   SERIAL        PRIMARY KEY,
    product_code         VARCHAR(200)  NOT NULL,
    product_url          TEXT          NOT NULL,
    size                 VARCHAR(10)   NOT NULL,
    gender               VARCHAR(10),
    product_description  TEXT,
    product_title        TEXT,
    style_category       VARCHAR(20),
    channel_product_id   VARCHAR(50),
    channel_item_id      VARCHAR(50),
    item_id              VARCHAR(50),
    skuid                VARCHAR(50),
    sku_name             VARCHAR(200),
    ean                  VARCHAR(50),
    stock_count          INTEGER       DEFAULT 0,
    original_price_gbp   NUMERIC(10,2),
    discount_price_gbp   NUMERIC(10,2),
    jingya_untaxed_price NUMERIC(12,2),
    taobao_store_price   NUMERIC(12,2),
    last_checked         TIMESTAMP     DEFAULT CURRENT_TIMESTAMP,
    is_published         BOOLEAN       DEFAULT FALSE,
    source_site          VARCHAR(100),
    source_offer_url     TEXT,
    source_price_gbp     NUMERIC(10,2),
    UNIQUE (product_code, size)
);


-- ---------- 3-6. barbour_supplier_map：供应商选源映射 ----------
CREATE TABLE barbour_supplier_map (
    product_code VARCHAR(50)  PRIMARY KEY,
    site_name    VARCHAR(100) NOT NULL            -- 对齐 barbour_offers.site_name
);


-- ---------- 3-7. barbour_product_candidates：匹配候选表 ----------
CREATE FUNCTION trg_bpc_touch()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at := NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TABLE barbour_product_candidates (
    id                  SERIAL        PRIMARY KEY,
    site_name           VARCHAR(100)  NOT NULL,
    source_url          TEXT          NOT NULL,
    style_name          VARCHAR(255)  NOT NULL,
    color               VARCHAR(100)  NOT NULL,
    size                VARCHAR(20)   NOT NULL,
    gender              VARCHAR(20),
    category            VARCHAR(100),
    title               VARCHAR(255),
    product_description TEXT,
    match_keywords      TEXT[],
    created_at          TIMESTAMP     DEFAULT NOW(),
    updated_at          TIMESTAMP     DEFAULT NOW(),
    UNIQUE (site_name, source_url, size)
);

CREATE TRIGGER bpc_touch
BEFORE UPDATE ON barbour_product_candidates
FOR EACH ROW EXECUTE FUNCTION trg_bpc_touch();
